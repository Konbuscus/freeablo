#include "vec2fix.h"
#include <misc/assert.h>

FixedPoint Vec2Fix::magnitude() const { return FixedPoint(x * x + y * y).sqrt(); }

void Vec2Fix::normalise()
{
    if (x == 0 && y == 0)
        return;

    FixedPoint mag = magnitude();
    x = x / mag;
    y = y / mag;
}

Misc::Direction Vec2Fix::getIsometricDirection() const
{
    using namespace Misc;

    // First we calculate the direction normally, not accounting for irometric perspective.

    auto calculate = [this]() {
        //                            |n_ne_line_x
        //                            |         |e_ne_line_x
        //     |        |             |         |
        //     |        | _.---+----. |         |
        //     |      ,`|'           `|-.       |
        //     |   ,-'  |      N     /|  `-.    |
        //     |  /     |\          / |     ,'  |
        //     |,'      | \        /  |      `. |
        //     +     NW |  \      ,'  | NE     \|
        //    `+.._     |   \     /   |     _.-'|
        //    ;|   `-._ |    \   /    | ,,-'    |
        //   ; |       `+..  `. /,  ,-|'        |:
        //  .. |  W     |  ::-._:-    |    E    |.
        //   : |        | _,,-'+`-.   |         |;
        //    :|      _.+'   .'|\   `-+._       |
        //    :| _,,-'  |    |   \    |  `-._   |
        //    .+'       |   /     \   |      `-.|
        //     |`.   SW |  /       \  |SE    ,' |
        //     |  \     | /    S   `. |     /   |
        //     |   `-.  |/          | |  ,-\    |
        //     |      `-|:           \|-'       |
        //     |        | `----+---'' |         |

        // We calculate the direction by looking directly at the normalised x and y values of the vector.
        // Why do this instead of just using atan and thresholding like a normal person? Because then I'd need
        // to implement a fixed point version of atan :v

        Vec2Fix n = *this;
        n.normalise();

        static FixedPoint n_ne_line_x = "0.382683";
        static FixedPoint e_ne_line_x = "0.9239";
        FixedPoint e_se_line_x = e_ne_line_x;
        FixedPoint s_se_line_x = n_ne_line_x;

        FixedPoint n_nw_line_x = FixedPoint(0) - n_ne_line_x;
        FixedPoint w_nw_line_x = FixedPoint(0) - e_ne_line_x;
        FixedPoint w_sw_line_x = w_nw_line_x;
        FixedPoint s_sw_line_x = n_nw_line_x;

        if (n.x > 0)
        {
            if (n.y > 0)
            {
                if (n.x > n_ne_line_x)
                {
                    if (n.x > e_ne_line_x)
                        return Direction::east;
                    else
                        return Direction::north_east;
                }
                else
                {
                    return Direction::north;
                }
            }
            else
            {
                if (n.x > s_se_line_x)
                {
                    if (n.x > e_se_line_x)
                        return Direction::east;
                    else
                        return Direction::south_east;
                }
                else
                {
                    return Direction::south;
                }
            }
        }
        else
        {
            if (n.y > 0)
            {
                if (n.x < n_nw_line_x)
                {
                    if (n.x < w_nw_line_x)
                        return Direction::west;
                    else
                        return Direction::north_west;
                }
                else
                {
                    return Direction::north;
                }
            }
            else
            {
                if (n.x < s_sw_line_x)
                {
                    if (n.x < w_sw_line_x)
                        return Direction::west;
                    else
                        return Direction::south_west;
                }
                else
                {
                    return Direction::south;
                }
            }
        }
    };

    Misc::Direction normalDirection = calculate();

    Misc::Direction mapping[] = {Direction::north_east,
                                 Direction::north,
                                 Direction::north_west,
                                 Direction::west,
                                 Direction::south_west,
                                 Direction::south,
                                 Direction::south_east,
                                 Direction::east};

    Misc::Direction isometric = mapping[size_t(normalDirection)];
    return isometric;
}

// generated by scripts/gen_atan_lut.py
constexpr size_t atanLutSize = 64;
static const FixedPoint atanLut[atanLutSize] =
{
    FixedPoint("0.0"),
    FixedPoint("0.8951737102110744"),
    FixedPoint("1.7899106082460694"),
    FixedPoint("2.6837751594689845"),
    FixedPoint("3.576334374997351"),
    FixedPoint("4.467159061389273"),
    FixedPoint("5.35582504285519"),
    FixedPoint("6.241914347415048"),
    FixedPoint("7.125016348901798"),
    FixedPoint("8.004728857292855"),
    FixedPoint("8.880659150520245"),
    FixedPoint("9.752424941653784"),
    FixedPoint("10.619655276155134"),
    FixedPoint("11.481991354748095"),
    FixedPoint("12.339087278326195"),
    FixedPoint("13.19061071220685"),
    FixedPoint("14.036243467926479"),
    FixedPoint("14.875682001638797"),
    FixedPoint("15.708637829015744"),
    FixedPoint("16.534837857345156"),
    FixedPoint("17.35402463626132"),
    FixedPoint("18.165956529225532"),
    FixedPoint("18.970407808486545"),
    FixedPoint("19.767168676791652"),
    FixedPoint("20.556045219583467"),
    FixedPoint("21.336859291805652"),
    FixedPoint("22.109448343751673"),
    FixedPoint("22.873665190626713"),
    FixedPoint("23.629377730656817"),
    FixedPoint("24.37646861667477"),
    FixedPoint("25.114834886144564"),
    FixedPoint("25.844387554560335"),
    FixedPoint("26.56505117707799"),
    FixedPoint("27.276763383113682"),
    FixedPoint("27.979474388480146"),
    FixedPoint("28.673146489434995"),
    FixedPoint("29.357753542791276"),
    FixedPoint("30.033280435995138"),
    FixedPoint("30.699722550814414"),
    FixedPoint("31.35708522400993"),
    FixedPoint("32.005383208083494"),
    FixedPoint("32.64464013491648"),
    FixedPoint("33.274887984834926"),
    FixedPoint("33.89616656336391"),
    FixedPoint("34.5085229876684"),
    FixedPoint("35.1120111844222"),
    FixedPoint("35.706691400602885"),
    FixedPoint("36.2926297284796"),
    FixedPoint("36.86989764584402"),
    FixedPoint("37.43857157233304"),
    FixedPoint("37.99873244250467"),
    FixedPoint("38.550465296157725"),
    FixedPoint("39.0938588862295"),
    FixedPoint("39.62900530446429"),
    FixedPoint("40.155999624919325"),
    FixedPoint("40.674939565261546"),
    FixedPoint("41.18592516570965"),
    FixedPoint("41.68905848538856"),
    FixedPoint("42.18444331578877"),
    FixedPoint("42.67218491095885"),
    FixedPoint("43.15238973400541"),
    FixedPoint("43.6251652194306"),
    FixedPoint("44.09061955080086"),
    FixedPoint("44.54886145321272")
};

// Works for the the 0-45 degree range
static FixedPoint atanLutLookup(FixedPoint y, FixedPoint x)
{
    FixedPoint ratio = y / x;
    FixedPoint lookup = ratio * (atanLutSize-1);

    int64_t index1 = lookup.intPart();
    release_assert(index1 < int64_t(atanLutSize));

    FixedPoint indexRatio = lookup.fractionPart();

    if (indexRatio == 0)
        return atanLut[index1];

    int64_t index2 = index1 + 1;
    release_assert(index2 < int64_t(atanLutSize));

    return atanLut[index1] * indexRatio + atanLut[index2] * (FixedPoint(1) - indexRatio);
}

FixedPoint Vec2Fix::atan2Degrees(Vec2Fix v)
{
    // Approach roughly taken from here: https://stackoverflow.com/q/650797
    // I tried implementing https://golang.org/src/math/atan.go and http://dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization/
    // with our FixedPoint class, but goth gave pretty bad results (often off by more than 2 degrees), and this simple LUT approach
    // seems to work reasonably well.

    v.normalise(); // required to make sure we don't exceed the range of our lookup table

    // The rest of this function is written assuming a normal maths axis like
    // cmath atan2, with y increasing up, not down. So, we just flip y here.
    v.y = FixedPoint(0) - v.y;

    if (v.x == 0)
        return v.y > 0 ? 90 : 270;

    if (v.y == 0)
        return v.x > 0 ? 0 : 180;

    // top right
    if (v.x > 0 && v.y > 0)
    {
        if (v.x > v.y)
            return atanLutLookup(v.y, v.x);
        else
            return FixedPoint(90) - atanLutLookup(v.x, v.y);
    }

    // top left
    if (v.x < 0 && v.y > 0)
    {
        FixedPoint posX = v.x.abs();

        if (posX > v.y)
            return FixedPoint(180) - atanLutLookup(v.y, posX);
        else
            return FixedPoint(90) + atanLutLookup(posX, v.y);
    }

    // bottom left
    if (v.x < 0 && v.y < 0)
    {
        FixedPoint posX = v.x.abs();
        FixedPoint posY = v.y.abs();

        if (posX > posY)
            return FixedPoint(180) + atanLutLookup(posY, posX);
        else
            return FixedPoint(270) - atanLutLookup(posX, posY);
    }

    // bottom right
    if (v.x > 0 && v.y < 0)
    {
        FixedPoint posY = v.y.abs();

        if (v.x > posY)
            return FixedPoint(360) - atanLutLookup(posY, v.x);
        else
            return FixedPoint(270) + atanLutLookup(v.x, posY);
    }

    release_assert(false);
    return 0;
}


Vec2Fix Vec2Fix::operator-(const Vec2Fix& other) const { return Vec2Fix(x - other.x, y - other.y); }
